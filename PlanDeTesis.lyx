#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
date{}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Thesis Proposal
\begin_inset Newline newline
\end_inset


\series bold

\begin_inset VSpace bigskip
\end_inset


\series default
\size small
\color black
Submitted in partial fulfillment of the requirements for the degree of
\size default
\color inherit

\begin_inset Newline newline
\end_inset

Ph.D.
 in Computer Science
\end_layout

\begin_layout Standard
\align center

\series bold
SpIRIT: Smart Identification of Refactoring opportunITies
\begin_inset Newline newline
\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Mg.
 Santiago A.
 Vidal
\end_layout

\begin_layout Standard
\align center
Student
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Dra.
 Claudia A.
 Marcos
\end_layout

\begin_layout Standard
\align center
Advisor 
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Dr.
 Andrés Díaz Pace
\end_layout

\begin_layout Standard
\align center
Co-Advisor
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Address
\align center
Facultad de Ciencias Exactas
\begin_inset Newline newline
\end_inset

Departamento de Computación y Sistemas
\begin_inset Newline newline
\end_inset

Universidad Nacional del Centro de la Pcia.
 de Bs.
 As.
\begin_inset Newline newline
\end_inset

March 2012
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Abstract
\end_layout

\begin_layout Section*

\lang spanish
Resumen
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Section
System Evolution
\end_layout

\begin_layout Standard
Once systems are developed and deployed, they will become progressively
 less useful due to changes in the environment 
\begin_inset CommandInset citation
LatexCommand citep
key "Lehman1985"

\end_inset

.
 The fact that a system becomes progressively less useful causes software
 aging 
\begin_inset CommandInset citation
LatexCommand citep
key "Parnas1994"

\end_inset

 and the need to evolve the system to new requirements preserving the simplicity
 and extensibility of the software.
 This situation was identified by Lehman 
\begin_inset CommandInset citation
LatexCommand cite
key "Lehman1985"

\end_inset

 during the formulation of the following laws:
\end_layout

\begin_layout Itemize
Continuing Change: A system that is used in a real-world environment must
 be continually adapted, otherwise it becomes progressively less satisfactory.
\end_layout

\begin_layout Itemize
Increasing Complexity: As a system is evolved, its complexity increases
 unless work is done to maintain or reduce such complexity.
\end_layout

\begin_layout Standard
An inference from these laws is that software maintenance is necessary in
 order to avoid software aging and to simplify the evolution of systems.
 Software maintenance is defined as:
\end_layout

\begin_layout Itemize
The process of modifying a software system or component after delivery to
 correct faults, improve performance or other attributes, or adapt to a
 changed environment 
\begin_inset CommandInset citation
LatexCommand cite
key "IEEE1999-Std610-12"

\end_inset

.
\end_layout

\begin_layout Itemize
A software product undergoes modifications to code and associated documentation
 due to a problem or the need for improvement.
 The objective is to modify the existing software product while preserving
 its integrity 
\begin_inset CommandInset citation
LatexCommand cite
key "ISOStd"

\end_inset

.
\end_layout

\begin_layout Standard
Maintenance activities have been categorized into four classes 
\begin_inset CommandInset citation
LatexCommand cite
key "Lientz1980"

\end_inset

:
\end_layout

\begin_layout Itemize
Adaptive: modification of software environment.
\end_layout

\begin_layout Itemize
Perfective: implementation of new user requirements.
\end_layout

\begin_layout Itemize
Corrective: reparation of errors.
\end_layout

\begin_layout Itemize
Preventive: prevention of future problems.
\end_layout

\begin_layout Standard
Some research has shown that approximately 75% of maintenance falls into
 adaptive and perfective classes 
\begin_inset CommandInset citation
LatexCommand cite
key "Lientz1980,Nosek,Pigoski1997"

\end_inset

.
 That is to say that the addition of new user requirements or the modification
 of the existing ones is one of the main problems of software evolution
 and maintenance 
\begin_inset CommandInset citation
LatexCommand cite
key "Bennett2000"

\end_inset

.
\end_layout

\begin_layout Standard
In order to make changes in a system, it is necessary to understand it.
 This is hard to do because when a legacy system must be extended, adapted
 or restructured to obtain a more modular system some of the following problems
 may emerge 
\begin_inset CommandInset citation
LatexCommand cite
key "Demeyer2003"

\end_inset

: the original developers are not available, obsolete programming techniques
 or languages were used, large changes were applied disregarding to the
 original design, the documentation is incomplete or it does not exist,
 there are no test cases, etc.
 All of these problems make maintenance difficult and expensive.
 Another attribute of the system that must be considered is its complexity.
 The more complex a system is, the more expensive it is to maintain 
\begin_inset CommandInset citation
LatexCommand cite
key "Banker1993"

\end_inset

.
 
\end_layout

\begin_layout Standard
For these reasons, in order to extend, adapt or improve the code a legacy
 system, reverse engineering techniques are generally used 
\begin_inset CommandInset citation
LatexCommand cite
key "Cross1992"

\end_inset

 (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Addition-of-requirements"

\end_inset

).
 Reverse engineering is the process of analyzing a subject system to identify
 the system’s components and their interrelationships and to create representati
ons of the system in another form or at a higher level of abstraction.
 Once the system is understood, new requirements or restructurings can be
 added to the system through re-engineering 
\begin_inset CommandInset citation
LatexCommand citep
key "Cross1992"

\end_inset

.
 Re-engineering is the examination and modification of a subject system
 to reconstitute it in a new form and the subsequent implementation of the
 new form.
 
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ReverseEngineeringAndReengineering.eps
	BoundingBox 25bp 570bp 375bp 827bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Addition of requirements to a legacy system.
\begin_inset CommandInset label
LatexCommand label
name "fig:Addition-of-requirements"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Incorporating requirements involves the addition of new source code and/or
 the restructuring of existing code, taking into account the maintainability
 and modularity of the resulting code.
 The technique known as refactoring 
\begin_inset CommandInset citation
LatexCommand citep
key "Fowler1999"

\end_inset

 is used in order to achieve this goal.
 Refactoring is the process of changing a software system in such a way
 that it does not alter the external behavior of the code yet improves its
 internal structure.
 This process allows the restructuration of the source code improving the
 effort needed to make future modifications of the system.
 Some benefits that are derived from applying refactorings are: reduction
 of duplicate code, improvement of quality attributes such as the legibility
 of the code, maintainability, conceptual integrity, or reduction of coupling.
 For these reasons, refactoring can be seen as a viable strategy to deal
 with software evolution.
 Furthermore, some agile development methodologies, such as XP 
\begin_inset CommandInset citation
LatexCommand cite
key "Beck2004"

\end_inset

, present refactoring as one of the most important practices.
\end_layout

\begin_layout Standard
The refactoring activities of the code are the following 
\begin_inset CommandInset citation
LatexCommand cite
key "Mens2004"

\end_inset

:
\end_layout

\begin_layout Enumerate
Identify the code fragments where the system should be refactored.
\end_layout

\begin_layout Enumerate
Determine which refactorings should be applied to the code fragments.
\end_layout

\begin_layout Enumerate
Check whether the refactoring to be applied preserves the external behavior
 of the code.
 
\end_layout

\begin_layout Enumerate
Apply the refactoring.
\end_layout

\begin_layout Enumerate
Assess the effects of the refactoring on quality characteristics of the
 software (e.g., complexity, maintainability) or the process (e.g., productivity,
 cost, effort).
 
\end_layout

\begin_layout Enumerate
Maintain consistency between the refactored code and related software artifacts
 (e.g., documentation, requirements, tests).
\end_layout

\begin_layout Standard
With the goal of easily applying refactorings, most of the current IDEs
 (e.g., Eclipse
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.eclipse.org/
\end_layout

\end_inset

, NetBeans
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.netbeans.org/
\end_layout

\end_inset

) include tools that support the semi-automatic application of specific
 refactorings.
 These tools are useful because they increase productivity and reduce debugging
 and testing 
\begin_inset CommandInset citation
LatexCommand cite
key "OConnor2005"

\end_inset

.
\end_layout

\begin_layout Standard
In spite of the automation of these tools the developer must participate
 actively in the process of refactoring.
 Also, as most of the refactoring tools does not support the assessing of
 the effects of applying a refactoring, the developer must apply a refactoring
 in order to measure the effects.
 If the effects are not as expected the developer should undo the changes
 being this task time-consuming.
\end_layout

\begin_layout Section
Improving Maintenance with Refactoring
\end_layout

\begin_layout Standard
As mentioned above, the first activity of a refactoring process is the identific
ation of the code fragments that should be refactorized in order to improve
 its evolvability.
 In this context, we call 
\emph on
hot spots
\emph default
 to these code fragments in which a problem was detected.
 
\end_layout

\begin_layout Standard
The activity of identifying hot spots is usually achieved by means of code
 smells 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

.
 Code smells are symptoms in the source code that usually allow the identificati
on of a deeper problem.
 In this way, a code smell acts as an anti-pattern indicating code that
 should be improved.
 Some of the symptoms used by code smells are duplicated code, too large
 methods or classes, long list of parameters, violations in the encapsulation
 of a class, etc.
 A popular catalog of code smells is the one proposed by Fowler and Beck
 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

 (Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:A-code-smell"

\end_inset

).
 For each code smell, there is an associated refactoring (or a group of
 them) to solve the problem.
 For example, the code smell Data Class identifies the situation in which
 a class contains data but not behavior.
 In this case, the refactoring suggested is to add behavior that belongs
 to the class but that is implemented in other classes by using the Move
 Method refactoring.
\end_layout

\begin_layout Standard
In order to help the developer to find code smells in systems, several tools
 such as PMD
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pmd.sourceforge.net/
\end_layout

\end_inset

 and FindBugs
\begin_inset Foot
status open

\begin_layout Plain Layout
http://findbugs.sourceforge.net/
\end_layout

\end_inset

 are available.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="9cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scope
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Code Smells
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Within Classes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comments, Dead Code, Duplicated Code, Inconsistent Names, Large Class, Long
 Method, Long Parameter List, Speculative Generality, Type Embedded in Name,
 Uncommunicative Name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Between Classes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data Class, Data Clumps, Divergent Change, Feature Envy, Inappropriate Intimacy,
 Lazy Class, Message Chains, Middle Man, Parallel Inheritance Hierarchies,
 Primitive Obsession, Refused Bequest, Shotgun Surgery
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A code smell catalog.
\begin_inset CommandInset label
LatexCommand label
name "tab:A-code-smell"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also, object-oriented metrics 
\begin_inset CommandInset citation
LatexCommand cite
key "Chidamber1994"

\end_inset

 are useful to identify hot spots to be refactored.
 Through the use of this kind of metrics several problems such as methods
 with high complexity or excessive dependencies between classes can be spotted.
\end_layout

\begin_layout Standard
Depending on the technique to identify the hot spots, they can been detected
 by analyzing the last version of a system 
\begin_inset CommandInset citation
LatexCommand cite
key "Lanza2006,Tsantalis2010"

\end_inset

 or the whole history of the system 
\begin_inset CommandInset citation
LatexCommand cite
key "Lanza2001,Ratzinger2007"

\end_inset

.
 The latter, is specially useful to understand when and how a hot spot was
 created.
\end_layout

\begin_layout Standard
Nevertheless, the identification of code fragments that should be refactored
 is still challenging.
 Many of the hot spots identified by the refactoring tools do not always
 indicate a problem, that is, they are false positives.
 For example, some long classes, such as those that implement a parser,
 are not necessarily a design problem.
 Also, determining the way in which a hot spot should be refactored is not
 always straightforward.
 In some cases several code restructurings are needed in order to ensure
 that the behavior of the code does not change 
\begin_inset CommandInset citation
LatexCommand cite
key "Mens2004"

\end_inset

.
 
\end_layout

\begin_layout Standard
Another problem is that when tools are used to detect hot spots that should
 be refactored, the tools usually find a large number of hot spots.
 The refactoring of all the hot spots is a time and effort consuming task.
 Furthermore, the refactorization of a hot spot is not necessarily urgent.
 So, the developer does not know with certainty which of them should have
 a high priority because of their relevance.
 Regarding the priority of the components to be refactorized, some researchers
 have suggested that those components of code that suffered many changes
 in the past (specially the recent past), are more likely to be modified
 in the future than those that were not modified 
\begin_inset CommandInset citation
LatexCommand cite
key "Mens2001,Girba2004"

\end_inset

.
 However, few studies have been published following this hypothesis with
 the goal of prioritizing refactorings.
\end_layout

\begin_layout Standard
Determining the set of refactorings to be applied in order to fix a hot
 spot is not trivial.
 This is because the refactoring to be applied depends on the code smell
 and the context in which the refactoring is applied.
 For example, in some scenarios the application of the refactoring proposed
 by the code smell is not possible.
 So, additional refactorings should be applied in order to enable the applicatio
n of the proposed refactoring.
 For example, several code smells can be fixed by applying 
\emph on
Move Method
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

.
 However, if the method to be moved uses an instance variable that it is
 only used inside the method, the variable should be moved first using 
\emph on
Move Field
\emph default
.
\end_layout

\begin_layout Standard
When a hot spot is found it is difficult for the developer to asses the
 pros and cons of refactoring it.
 This analysis should be based in the effort required to apply the refactoring
 and a set of metrics to show the developer the possible improvements in
 the quality of the source code.
\end_layout

\begin_layout Standard
For these reasons, 
\color black
we believe that it is desirable to have tools that provide better assistance
 to the developer during the refactoring process detecting hot spots, prioritizi
ng them, making automatic analysis of
\color inherit
 tradeoff and suggesting and applying refactorings.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
EXPLICAR BAD SMELLS
\end_layout

\begin_layout Plain Layout
TIENE QUE QUEDAR BIEN CLARO CUALES SON LOS PROBLEMAS QUE VAMOS A ATACAR
\end_layout

\begin_layout Plain Layout
Lo importante es discriminar: problemas concretos, hipotesis, enfoque de
 solucion.
\end_layout

\begin_layout Plain Layout
Los mayores problemas en el momento de realizar un refactoring son...
 Nosotros buscaremos solucionar esos problemas en este trabajo.
 
\end_layout

\begin_layout Plain Layout
Problemas:
\end_layout

\begin_layout Itemize
deteccion de los lugares a refactorizar en un sistema (hot spots)
\end_layout

\begin_layout Itemize
priorizacion de los hot spots segun que tan criticos son para el sistema
\end_layout

\begin_layout Itemize
Obtener un conjunto de posibles refactorings a aplicar
\end_layout

\begin_layout Itemize
"analisis costo-beneficio de los distintos refactorings que pueden ser aplicados
 para resolver el problema teniendo en cuenta las ventajas y desventajas
 de cada uno
\end_layout

\end_inset


\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
In this section we review different approaches for analyzing the evolution
 and maintenance of systems.
\end_layout

\begin_layout Standard
Several approaches have been focused on the analyze of several aspects of
 the history of systems.
 Some of the approaches try to discover bad smells in the source code in
 order to propose refactorings to remove those bad smells.
 Other approaches have dealt with the use of software metrics to discover
 potential design problems in the source code.
 Additionally, some works use visualization techniques in order to identify
 the changes during the evolution of a system.
 
\end_layout

\begin_layout Standard
Chatzigeorgiou and Manakos 
\begin_inset CommandInset citation
LatexCommand cite
key "Chatzigeorgiou2010"

\end_inset

 study the evolution of the bad smells of a system through its history.
 Specifically, they analyze the occurrence of three kind of bad smells initially
 presented by Fowler 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

.
 This study identified that most of the bad smells were created when new
 features were added to the systems.
 Also, it identified that most of the bad smells were not removed.
\end_layout

\begin_layout Standard
Hayashi et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Hayashi2006"

\end_inset

 propose a software agent that analyzes the changes made by a developer
 in a system.
 If a change creates a bad smell the agent suggests a Fowler's refactoring
 to be applied.
 While some modifications, to be proposed by the agent, are formally defined
 in this paper, it is not clear how the agent identifies the bad smell or
 which kind of them are supported.
\end_layout

\begin_layout Standard
Gîrba and Ducasse 
\begin_inset CommandInset citation
LatexCommand cite
key "Girba2006"

\end_inset

 present a meta-model called Hismo to analyze the evolution of systems through
 their history.
 Hismo is constructed in a generic way (therefore, it can be used with any
 programming language) and it models evolution as a first-class entity.
 The validation of this meta-model involves different case studies.
\end_layout

\begin_layout Standard
LinHui et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "LinHui2010"

\end_inset

 analyze the history of systems to identify the relationships between different
 modules of an architecture.
 Based on this information refactorings are proposed.
 Additionally, an interactive process based on domain-knowledge is proposed
 to apply the refactorings.
\end_layout

\begin_layout Standard
Tsantalis and Chatzigeorgiou 
\begin_inset CommandInset citation
LatexCommand cite
key "Tsantalis2011"

\end_inset

 follow the hypothesis that those fragments of code that were modified in
 the past are more likely to be modified in the future 
\begin_inset CommandInset citation
LatexCommand cite
key "Mens2001"

\end_inset

.
 Using this hypothesis the authors rank refactoring suggestions to deal
 with bad smells.
 In this ranking, those refactorings whose target code was modified in the
 past will have the highest priority.
 To calculate the probability of change of a given component, the approach
 uses historical volatility models taken from the field of financial markets.
\end_layout

\begin_layout Standard
Tsantalis and Chatzigeorgiou also present approaches to identify state-checking
 problems (the use of if clauses to decide the behavior of an object instead
 of polymorphism) and the decomposition of large methods 
\begin_inset CommandInset citation
LatexCommand cite
key "Tsantalis2010,Tsantalis2011a"

\end_inset

.
 In these approaches the proposed refactorings are ranked according to the
 impact of the refactorings on the code (i.e.
 number of modified statements).
\end_layout

\begin_layout Standard
D'Ambros et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "D'Ambros2010a"

\end_inset

 analyze the relationship between bad smells and software defects.
 This experiment uses several Java systems to identify the frequency of
 occurrence of bad smells in the systems and to calculate the correlation
 between bad smells and software defects.
 This work identifies that the systems with bad smells are more likely to
 have bugs than those systems without bad smells.
\end_layout

\begin_layout Standard
Lanza and Marinescu 
\begin_inset CommandInset citation
LatexCommand cite
key "Lanza2006"

\end_inset

 present a strategy to identify code problems called disharmonies.
 The disharmonies are defined based on a combination of different metrics
 that have to exceed a predetermine threshold.
 They also proposes the use of a visualization technique called Class Blueprint
 in order to complement the detection strategy.
\end_layout

\begin_layout Standard
Marinescu et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Marinescu2010"

\end_inset

 present a tool to detect a set of bad smells such as God Class, and Feature
 Envy.
 For each bad smell detected, the tool proposes a list of 
\emph on
refactorings tips
\emph default
 to be applied.
\end_layout

\begin_layout Standard
Macia et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Macia2012,Macia2012a"

\end_inset

 analyze the impact of bad smells in the architectural design of systems.
 They found that, in 60% of cases, the removal of a bad smell helps the
 architecture, stopping its degradation.
 Also, they report that some kind of bad smells negatively affects the evolution
 of systems.
 For this reason, their identification during early development stages alleviate
 the architecture degradation process.
\end_layout

\begin_layout Standard
Demeyer et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Demeyer2000"

\end_inset

 propose an approach to identify which refactorings were applied during
 the history of a system.
 This work is based on heuristics that use different metrics such as the
 total number of lines of code of a method or the number of hierarchy relationsh
ips of a class.
 This approach could be useful to understand the evolution of a system and
 to identify which components had a high degree of modification.
\end_layout

\begin_layout Standard
Ratzinger et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ratzinger2005"

\end_inset

 extends the definition of bad smells to 
\emph on
change smells
\emph default
 in order to identify possible classes of a system to be refactorized.
 This work proposes two change smells to identify coupling between classes.
 Specifically, one of them identifies the situation in which a main class
 is modified at the same time that other peripheral classes.
 The other smell identifies the situation in which a class only defines
 access methods to its variables and other class implements features based
 on the first class.
 Once a change smell is detected, a Fowler's refactoring is proposed.
 This work has identified an interesting relationship between the analysis
 of dependencies and the identification of bad smells.
\end_layout

\begin_layout Standard
Gîrba et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Girba2004"

\end_inset

 present a technique to discover classes that should be refactored.
 As 
\begin_inset CommandInset citation
LatexCommand cite
key "Tsantalis2011"

\end_inset

, this work is based on the hypothesis that those classes that were modified
 more frequently in the past, are more likely to be modified in the future.
 For this reason, this work analyze each class of a version of a system
 using an algorithm that determines the probability of change of the class
 in future versions.
 If the class is likely to change, then it is marked as candidate class
 to be refactored.
 To measure the change of a class between versions, only the addition or
 deletion of methods are considered.
 The paper does not cover the analysis of possible problems in the classes
 to be refactored or the suggestion of the refactorings that should be applied.
\end_layout

\begin_layout Standard
Liu et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Liu2011"

\end_inset

 analyze the relationships between a set of 11 bad smells with the goal
 of proposing an order of the refactorings to be applied.
 The goal of the approach is obtain a lower number of restructurings than
 the case in which the refactorings are applied in a random sequence.
 The sequence of refactorings is based on how the refactorings affect the
 source code.
 However, the approach does not consider other factors, such as the severity
 of bad smells.
 Since the algorithm used to compute the sequence of refactorings relied
 on a previous manual analysis of the dependencies between bad smell it
 is not possible to consider other bad smells in the sequences.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
We analyze the relationships among different kinds of bad smells and their
 influence on detection and resolution sequences.
 We identify the need to arrange detection and resolution sequences of different
 kinds of bad smells using a motivating example.
 We also recommend a resolution sequence for commonly occurring bad smells,
 and validate it on two nontrivial applications.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ratzinger et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ratzinger2007"

\end_inset

 propose the use of data mining techniques to predict refactorings based
 on the history of a system.
 Several metrics are used in the identification, such as size of a class,
 number of authors of a class, complexity, number of bugs, etc.
 Using these metrics, the approach identifies the refactorings that were
 applied in the past.
 After a training phase, the approach can predict the number of refactorings
 that could be applied in a future version.
\end_layout

\begin_layout Standard
Wong et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Wong2011"

\end_inset

 propose an approach to detect violations in the modularity of components.
 This detection is achieved by identifying which components had evolved
 together during the history of a system.
 In these cases, the authors assume that the components are very coupled
 and a violation to the modularity must exist.
\end_layout

\begin_layout Standard
Xing and Stroulia 
\begin_inset CommandInset citation
LatexCommand cite
key "Xing2005"

\end_inset

 present an algorithm called UMLDiff to identify changes in the design between
 two versions of a system.
 The input of the algorithm are the UML meta-models of the classes to be
 compared.
 This algorithm is used in 
\begin_inset CommandInset citation
LatexCommand cite
key "Xing2003"

\end_inset

 to identify and classify those refactorings that were applied during the
 history of a system.
\end_layout

\begin_layout Standard
D'Ambros and Lanza 
\begin_inset CommandInset citation
LatexCommand cite
key "D'Ambros2009"

\end_inset

 present visualization techniques to analyze the evolution of a system based
 on its different versions.
 They present two groups of visualizations: 
\emph on
in the large
\emph default
, and 
\emph on
in the small
\emph default
.
 The former focuses on identifying changes and different commits into a
 class.
 The latter focuses on finding bugs in the classes and also on analyzing
 the size and complexity of the bugs.
 The same authors propose a visualization technique to calculate coupling
 between modules, correlation between classes and complexity of classes
 
\begin_inset CommandInset citation
LatexCommand cite
key "D'Ambros2010"

\end_inset

.
 An interesting feature of this work is that it focuses on the collaborative
 work during the maintenance of a system through the addition of annotations
 on the visualizations of the components.
\end_layout

\begin_layout Standard
Schofield et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Schofield2006"

\end_inset

 analyze the changes during the history of a system using heuristics.
 These heuristics are based on different metrics, analysis of return of
 investment after applying a refactoring, and differences of code between
 different versions.
\end_layout

\begin_layout Standard
Lanza 
\begin_inset CommandInset citation
LatexCommand cite
key "Lanza2001"

\end_inset

 proposes the use of an evolution matrix to visualize the changes of classes
 during the history of a system.
 Each cell of the matrix contains a specific version of a class.
 A class is visualized as a rectangle where the width and height are defined
 based on metrics (e.g.
 number of methods and number of instance variables).
 This work also proposes a categorization of the classes visualized on the
 matrix.
 These categories are patterns found during the history and they are based
 on the size of the classes, the percentage of modification between versions,
 and the creation or deletion of classes.
 While these patterns can help to identify several problems in the code,
 the supervision of the developer is needed because a high percentage of
 false positives.
 
\end_layout

\begin_layout Standard
Pinzger et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Pinzger2005"

\end_inset

 use Kiviat diagrams to analyze the trend of several metrics during the
 history of a system.
 The approach focuses on two kind of graphics: the first one shows metrics
 for a module and the second one focuses on metrics related to the relationships
 between modules.
\end_layout

\begin_layout Standard
Voinea et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Voinea2005"

\end_inset

 present a technique to visualize the evolution of systems using line-oriented
 displays.
 The different views have the goal of showing the changes of a component
 during the versions of a system, indicating the developers that made changes,
 establishing correlations between changes, and displaying which components
 have a high volatility ratio.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Habria que dividir los trabajos relacionados segun:
\end_layout

\begin_layout Itemize
Refactoring
\end_layout

\begin_layout Itemize
Analisis de historia
\end_layout

\begin_layout Itemize
Visualiacion
\end_layout

\begin_layout Plain Layout
Indicating the gap in knowledge and possible limitations 
\end_layout

\begin_layout Itemize
Few researchers have addressed the problem / issue / question of … 
\end_layout

\begin_layout Itemize
Previous work has only focused on / been limited to / failed to address
 … 
\end_layout

\begin_layout Itemize
A basic / common / fundamental / crucial / major issue of … 
\end_layout

\begin_layout Itemize
The central / core problem of 
\end_layout

\begin_layout Itemize
A challenging / An intriguing / An important / A neglected area in the field
 of … 
\end_layout

\begin_layout Itemize
Current solutions to X are inconsistent / inadequate / incorrect / ineffective
 / inefficient / over-simplistic / unsatisfactory 
\end_layout

\begin_layout Itemize
Many hypotheses regarding X appear to be ill-defined / unfounded / not well
 grounded / unsupported / questionable / disputable / debatable 
\end_layout

\begin_layout Itemize
The characteristics of X are not well understood / are misunderstood / have
 not been dealt with in depth.
 
\end_layout

\begin_layout Itemize
It is not yet known / has not yet been established whether X can do Y.
 
\end_layout

\begin_layout Itemize
X is still poorly / not widely understood.
 
\end_layout

\begin_layout Itemize
X is often impractical / not feasible / costly … 
\end_layout

\begin_layout Itemize
Techniques to solve X are computationally demanding / subject to high overheads
 / time consuming / impractical / frequently unfeasible.
 
\end_layout

\begin_layout Itemize
A major defect / difficulty / drawback / disadvantage / flaw of X is … 
\end_layout

\begin_layout Itemize
One of the main issues in our knowledge of / what we know about X is a lack
 of … 
\end_layout

\begin_layout Itemize
This particular / specific area of X has been overlooked / has been neglected
 / remains unclear … 
\end_layout

\begin_layout Itemize
Despite this interest, no one to the best of our knowledge / as far as we
 know has studied … 
\end_layout

\begin_layout Itemize
Although this approach is interesting, it suffers from / fails to take into
 account / does not allow for … 
\end_layout

\begin_layout Itemize
In spite of / Despite its shortcomings, this method has been widely applied
 to … 
\end_layout

\begin_layout Itemize
However, there is still a need for / has been little discussion on … 
\end_layout

\begin_layout Itemize
Moreover, other solutions / research programs / approaches have failed to
 provide … 
\end_layout

\begin_layout Itemize
Most studies have only focused / tended to focus on …
\end_layout

\begin_layout Itemize
To date / Until now this methodology has only been applied to … 
\end_layout

\begin_layout Itemize
There is still some / much / considerable controversy surrounding … 
\end_layout

\begin_layout Itemize
There has been some disagreement concerning / regarding / with regard to
 whether 
\end_layout

\begin_layout Itemize
There is little / no general agreement on … 
\end_layout

\begin_layout Itemize
The community has raised some issues / concerns about … 
\end_layout

\begin_layout Itemize
Concerns have arisen / been raised which question / call into question the
 validity of … 
\end_layout

\begin_layout Itemize
In the light of recent events in x, there is now some / much / considerable
 concern about …
\end_layout

\begin_layout Plain Layout
Giving general panorama of past-to-present literature 
\end_layout

\begin_layout Itemize
There is a considerable / vast amount of literature on … 
\end_layout

\begin_layout Itemize
In the literature there are many / several / a surprising number of / few
 examples of … 
\end_layout

\begin_layout Itemize
What we know / is known about X is largely based on … 
\end_layout

\begin_layout Itemize
Much / Not much / Very little is known about … 
\end_layout

\begin_layout Itemize
Many / Few studies have been published on … [Ref] 
\end_layout

\begin_layout Itemize
Various approaches have been proposed / put forward / suggested / hypothesized
 to solve this issue [Ref].
 
\end_layout

\begin_layout Itemize
X has been identified / indicated as being … [Ref] 
\end_layout

\begin_layout Itemize
X has been shown / demonstrated / proved / found to be … [Ref] 
\end_layout

\begin_layout Itemize
X has been widely investigated / studied / addressed … [Ref] 
\end_layout

\begin_layout Itemize
Xs have been receiving / gaining much attention due to … 
\end_layout

\begin_layout Itemize
In the traditional / classical approach, X is used to … 
\end_layout

\begin_layout Itemize
In recent years there has been considerable / growing interest in … [Ref]
\end_layout

\begin_layout Itemize
A growing body of literature has examined / investigated / studied / analyzed
 / evaluated … [Ref] 
\end_layout

\begin_layout Itemize
Much work on the potential of X has been carried out [Ref], yet / however
 there are still some critical issues … [Ref]
\end_layout

\begin_layout Plain Layout
Using the opinions of others to justify your criticism of someone’s work
 
\end_layout

\begin_layout Itemize
As mentioned by Burgess [2011], Henri’s argument / approach / reasoning
 relies too heavily on … 
\end_layout

\begin_layout Itemize
As others have highlighted [34, 45, 60], Ozil’s approach raises many doubts
 / is questionable … 
\end_layout

\begin_layout Itemize
Several authors / experts / researchers / analysts have expressed doubts
 about / called into question / challenged Guyot on the grounds that …..
 
\end_layout

\begin_layout Itemize
Marchesi [2010] has already noted an inconsistency with Hahn’s claim / methodolo
gy / method / results / approach … 
\end_layout

\begin_layout Itemize
Friedrich’s approach [2013] has not escaped criticism / been subjected to
 much criticism and has been strongly / vigorously challenged … 
\end_layout

\begin_layout Itemize
Many experts now contend / believe / argue that rather than using Pappov’s
 approach it might be more useful to … 
\end_layout

\begin_layout Itemize
Their analysis has not found / met with / received general acceptance …
 
\end_layout

\begin_layout Itemize
Some recent criticisms of / critical comments on Kim’s work are summarized
 in [25].
 
\end_layout

\begin_layout Itemize
The most well-known critic of Sadie’s findings is … who argued / proposed
 / suggested that an alternative explanation might be that / could be found
 in …
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen, the process of maintaining and evolving a system is a difficult
 and complex task.
 Also, it is a time-consuming task for developers and a costly one for customers.
 From the analysis of previous work can be observed that they have been
 limited to identify hot spots in the source code and to propose a set of
 predetermined refactorings in order to fix the hot spots.
 The approaches that use software metrics mostly focus on discovering the
 problems but no solutions are proposed.
 Also, few researchers have worked on software metrics related to package
 or methods levels, instead, most of them are based on classes.
 Working with different levels of granularity could help to identify other
 kind of problems in the source code.
 For this reason, we think that there is still a need for analyzing the
 relationship between methods, classes, and packages in order to discover
 potential maintenance and evolution problems.
\end_layout

\begin_layout Standard
A challenging issue is how to prioritize the refactorings to be proposed.
 We think that has been little discussion on the ranking of refactorings
 using several criteria and in the achievement of cost-benefit analysis
 of refactorings.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
It is evident that not all refactoring have the same importance or effect
 in a given situation.
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Thesis Proposal
\end_layout

\begin_layout Standard
In order to make easier the maintenance and evolution of a system, code
 refactorings 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

 must be applied to improve the internal structure of the source code without
 altering the external behavior of it.
 However, performing refactoring activities can be costly in time and money
 for both developers and customers.
 Additionally, when tools are used to identify possible hot spots to be
 refactored, the tools usually return a large list of hot spots.
 Due to the number of refactorings needed to fulfill with the fix of the
 hot spots proposed by the tools, the refactoring process is a difficult
 and time-consuming process for the developer.
 For this reason, our hypothesis is that if the refactoring effort is directed
 to restructure only those code fragments that are critical for the systems,
 the maintenance and evolution of the system will increase without spending
 excessive time restructuring the system.
 
\end_layout

\begin_layout Standard
Along this line, in this thesis we propose an approach that helps developers
 to achieve the task of refactoring an object-oriented system in order to
 improve its maintenance and evolvability.
 
\color black
We call this approach SpIRIT: Smart Identification of Refactoring opportunITies.
 The goal of SpIRIT is to help the developer during the refactorization
 process in order to simplify this task by: (1) assisting the developer
 detecting hot spots to be refactored, (2) prioritizing them, (3) making
 automated analysis of the costs and benefits of refactoring the hot spots
 and (4) suggesting and applying refactorings.
 
\end_layout

\begin_layout Standard

\color black
The SpIRIT approach consists of a set of activities in which a system is
 analyzed in order to find locations of the system that have potential evolution
ary or maintainability problems.
 Then, in order to reduce the number of hot spots to be refactored, SpIRIT
 will prioritize them based on their relevance.
 
\color inherit
The relevance of a component can be determined for different criteria such
 as the ratio of modification of the component, or the values of code metrics
 (e.g.
 cyclomatic complexity, number of dependencies, etc.) after applying a refactorin
g.

\color black
 When the developer chooses a hot spot to be fixed, the process suggest
 a set of refactorings that are suitable to it.
 For each refactoring, SpIRIT will inform of the advantages and disadvantages
 of their application.
 Finally, the developer may choose to apply any of the listed refactorings.
\end_layout

\begin_layout Standard

\color black
The scope of SpIRIT intends to support different programing languages, for
 this reason it will be build using Moose
\begin_inset Foot
status open

\begin_layout Plain Layout

\color black
http://moosetechnology.org/
\end_layout

\end_inset

 which is a platform for software analysis that allows the import of several
 programming languages such as Smalltalk, Java or C++.
\end_layout

\begin_layout Standard

\color black
In brief, in this thesis we expect to contribute to the maintenance and
 evolution of systems by proposing a refactoring approach.
 This approach will help developers to achieve the task of refactoring an
 object-oriented system by detecting an prioritizing hot spots to be refactored.
 Also, the process suggest refactorings to be applied in the hot spots and
 presents 
\color inherit
analysis of costs and benefits of applying each of them.
 In this way, we expect to reduce the effort needed to refactor a system
 by restructuring only those hot spots that are critical for a system.
\end_layout

\begin_layout Standard
In the next section the approach is described in detail.
\end_layout

\begin_layout Subsection

\series bold
Smart Identification of Refactoring Opportunities
\end_layout

\begin_layout Standard
The 
\color black
SpIRIT
\color inherit
 approach follows a refactoring process that takes as input an object-oriented
 system and it produces as output the same system refactored.
 The goal is to identify and improve those fragments of code that make it
 difficult the maintenance and evolution of the systems.
 As was aforementioned, we call hot spots to these fragments of code.
 In order to fulfill with the activities of the process, 
\color black
SpIRIT
\color inherit
 uses several techniques such as artificial intelligence or anti-pattern
 detection ones.
\end_layout

\begin_layout Standard
The process has four steps (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SPIRIT-process."

\end_inset

):
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/SpiritProcess.pdf
	scale 70
	BoundingBox 20bp 220bp 410bp 470bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The refactoring process.
\begin_inset CommandInset label
LatexCommand label
name "fig:SPIRIT-process."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Identifying hot spots: in this step is accomplished the identification of
 the code fragments that should be refactorized in order to improve the
 maintenance and evolution of the system.
\end_layout

\begin_layout Enumerate
Prioritizing hot spots: due to the priority of refactoring a hot spot or
 another is not the same, the identified hot spots should be ranked by different
 criteria.
\end_layout

\begin_layout Enumerate
Suggesting refactorings: a set of refactorings are suggested to the developer
 to be applied to the hot spot.
\end_layout

\begin_layout Enumerate
Applying refactorings: the refactorings selected previously are applied
 so that the hot spot under analysis is fixed.
 
\end_layout

\begin_layout Standard
In the following sections each step is explained in detail.
\end_layout

\begin_layout Subsubsection
Identifying Hot Spots
\end_layout

\begin_layout Standard
Several techniques are going to be used to identify hot spots.
 Some of then are code smells 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

, heuristics based on object-oriented metrics 
\begin_inset CommandInset citation
LatexCommand cite
key "Lanza2001"

\end_inset

, anti-patterns to detect design violations 
\begin_inset CommandInset citation
LatexCommand cite
key "Wong2011"

\end_inset

, and test profiling 
\begin_inset CommandInset citation
LatexCommand cite
key "Bergel2012"

\end_inset

.
 These techniques are going to search for different problems in the source
 code.
 Each of them must going to be associated with a set of refactorings to
 fix it.
 Depending on the kind of technique, the last version of the system or the
 whole history of versions are going to be used to identify problems.
 The use of the whole history of versions is useful to identify special
 situations such as classes that have not been changed for a number of versions
 or a class that grows more than certain percentage regarding it previous
 version.
 In contrast, the use of the last version of a system allow the identification
 of problems such as code duplication, or high complexity.
 We also will experiment by identifying patterns of hot spots that occurs
 together in the history of a system.
 Visualization will be helpful to accomplish this task.
\end_layout

\begin_layout Subsubsection
Prioritizing Hot Spots
\end_layout

\begin_layout Standard
In order to determine the most critical hot spots we propose the use of
 two strategies:
\end_layout

\begin_layout Enumerate
The first strategy is based on the rate of modification of the component
 in time.
 That is, the refactorizations will be proposed only on those components
 which have suffered many changes over the life of the system.
 The hypothesis behind this idea is that if a component had many changes
 during its life is likely to continue having changes 
\begin_inset CommandInset citation
LatexCommand cite
key "Mens2001"

\end_inset

.
 The benefits of this strategy are twofold.
 First, a more modifiable and maintainable system is obtained.
 Second, the cost of refactoring is lower than refactoring all the hot spots
 detected because only specific components are restructured.
 
\end_layout

\begin_layout Enumerate
The second strategy is based on the analysis of costs and benefits of applying
 a refactoring.
 That is, we plan to use several metrics such as the calculation of the
 quantitative ratio of improvement in the quality of the source code after
 the refactorization of a hot spot or the calculation of the effort needed
 to apply a refactoring.
 The goal of calculating these metrics is to create tradeoff analysis of
 the application of a refactoring (or a group of them).
\end_layout

\begin_layout Subsubsection
Suggesting Refactorings
\end_layout

\begin_layout Standard
The refactorings to be suggested to the developer will be those associated
 with the hot spot under analysis.
 However, since the refactoring to be applied depends on the context of
 the hot spot, the suggestion of the refactorings will also be based on
 the history of refactorings of the developer.
 That is, the process keeps a record of the refactorings applied by the
 developer and the circumstances in which those refactorings were applied.
 In this way, we will achieve the identification of additional refactorings
 to be applied in order to enable the application of the refactorings associated
 with the hot spots.
 Also, by mean of this technique the preferences of refactorization of a
 developer are implicitly identified.
 An additional advantage of keeping track of the refactorings applied for
 a developer is that in this way the refactorings to be applied to fix a
 hot spot can be inferred.
 This is specially useful when the set of refactorings to fix a hot spot
 are not predefined.
 This step will be accomplished by using a technique based on association
 rules 
\begin_inset CommandInset citation
LatexCommand cite
key "Agrawal94"

\end_inset

 and a Markov models 
\begin_inset CommandInset citation
LatexCommand cite
key "Rabiner1989"

\end_inset

.
 We think that this is an appropriate approach because of the fact that
 these kind of techniques help to learn developers' habits, preferences
 and interests to provide them personalized assistance with the tasks they
 perform with software applications 
\begin_inset CommandInset citation
LatexCommand cite
key "Lieberman1997,Hsu1999"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Applying Refactorings
\end_layout

\begin_layout Standard
As was said, in this step the refactorings selected previously are refactored
 in order to fix a hot spot.
 The code refactorings are applied automatically by the process.
 The developer’s intervention is eventually necessary for some decisions,
 such as the choice of the name of a new method.
 However, this step, as well all the refactoring process, must be supervised
 by the developer.
 In order to fulfill with this step, the existing IDE refactoring tools
 will be used.
\end_layout

\begin_layout Subsection
Validation
\end_layout

\begin_layout Standard
To validate our approach we will use different strategies which were used
 by related works to evaluated their approaches 
\begin_inset CommandInset citation
LatexCommand cite
key "Liu2011,Ratzinger2005,Tsantalis2010,Wong2011"

\end_inset

:
\end_layout

\begin_layout Itemize
Quantitative comparison
\begin_inset space \quad{}
\end_inset

We plan to apply our approach in different systems.
 Then, we will analyze the improvements of the systems by evaluating different
 code metrics such as cyclomatic complexity and coupling between objects
 
\begin_inset CommandInset citation
LatexCommand cite
key "Chidamber1994"

\end_inset

.
 We also will analyze the performance of the component and refactorings
 suggested by calculating the precision and recall values.
\end_layout

\begin_layout Itemize
Laboratory experiment
\begin_inset space \quad{}
\end_inset

Two group of developers will refactor a system.
 Both will obtain a list of identified hot spots but only one group will
 use our approach.
 We will evaluate the benefits of our approach comparing the time spending
 for each group in the refactorization and the quality of the resulting
 code by mean of a set of metrics.
\end_layout

\begin_layout Itemize
Evolution analysis
\begin_inset space \quad{}
\end_inset

We will create a branch of a system in order to continue its development
 by using our approach (that is, refactoring hot spots in the new version
 but not in the original).
 At the same time, the development of the original version will continue.
 Then, we will compare the new versions of the systems by analyzing the
 remaining hot spots and by evaluating different code metrics such as cyclomatic
 complexity and coupling between objects 
\begin_inset CommandInset citation
LatexCommand cite
key "Chidamber1994"

\end_inset

.
\begin_inset Note Comment
status collapsed

\begin_layout Itemize
We plan to create a branch of a system in order to continue its development
 by using our approach (that is, refactoring hot spots in the new version
 but not in the original).
 At the same time, the development of the original version will continue.
 Then, we will compare the new versions of the systems by analyzing the
 remaining hot spots and by evaluating different code metrics such as cyclomatic
 complexity and coupling between objects 
\begin_inset CommandInset citation
LatexCommand cite
key "Chidamber1994"

\end_inset

.
\end_layout

\begin_layout Itemize
Evaluation of other refactoring strategies
\begin_inset space \quad{}
\end_inset

In this strategy we will compare the results of refactoring the same hot
 spots using with different refactorings associated the the resolution of
 a hot spot.
 With this strategy we expect to analyze the improvements in the source
 code by the use of different metrics.
\end_layout

\begin_layout Itemize
Evaluation after refactoring
\begin_inset space \quad{}
\end_inset

Through this evaluation the changes in a component after refactoring it
 will be analyzed.
 If a better separation of the functionality was achieved by mean of the
 refactorization of a component, the changes in the component after refactoring
 it should decrease.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Current State
\end_layout

\begin_layout Standard
Currently, the detection of several bad smells and anti-patterns based on
 software metrics is under implementation.
 Also, the first draft of the architecture of 
\color black
SpIRIT
\color inherit
 have been created.
\end_layout

\begin_layout Standard
In order to identify those components which have suffered many changes over
 the life of the system the Hismo
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://www.moosetechnology.org/docs/hismo
\end_layout

\end_inset

 project is used.
 Hismo is a meta-model for software evolution analysis that allows the compariso
n of the different versions of a system 
\begin_inset CommandInset citation
LatexCommand cite
key "Girba2006"

\end_inset

.
 In this way, the first experimentation with the models of different Java
 and Smalltalk systems have been achieved.
\end_layout

\begin_layout Standard
Regarding the algorithm to identify the refactorings to be applied to a
 hot spot and possible additional restructurings, it was developed and was
 tested in the context of migrating OO systems to aspect-oriented ones 
\begin_inset CommandInset citation
LatexCommand cite
key "Vidal2010,Vidal2012"

\end_inset

.
 The results obtained during the suggestion of refactoring for aspects makes
 the algorithm promising for its application in this thesis.
 This algorithm uses association rules and a Markov model to 
\color black
identify the refactoring to be applied and the proposition of additional
 restructurings when they are necessary.
 In this context, a database of refactorings is used which contains information
 about the developer's interaction with the approach such as the context
 in which a refactoring was applied.
 Specifically, the association rules algorithm allows the generation of
 rules for identifying and proposing refactorings for a given hot spot.
 In addition, the Markov Model helps in the identification of additional
 activities to the refactoring that must be performed.

\color inherit
 
\end_layout

\begin_layout Section
Task Schedule
\end_layout

\begin_layout Standard
In this section we describe the activities that must be accomplished in
 order to finish the proposed approach:
\end_layout

\begin_layout Itemize
Design and implementation of the 
\color black
SpIRIT
\color inherit
 user interface.
 Time estimated: 2 months.
\end_layout

\begin_layout Itemize
Analysis and implementation of the 
\color black
SpIRIT
\color inherit
 mechanisms to detect hotspots to be refactored.
 Time estimated: 4 months.
\end_layout

\begin_layout Itemize
Analysis and implementation of the 
\color black
SpIRIT
\color inherit
 mechanisms to prioritize hotspots based on the rate of modification of
 the component.
 Time estimated: 2 months.
\end_layout

\begin_layout Itemize
Analysis and implementation of the 
\color black
SpIRIT
\color inherit
 mechanisms to rank refactorings to be applied to a hotspot based on cost-benefi
ts analysis.
 Time estimated: 5 months.
\end_layout

\begin_layout Itemize
Implementation of strategies to visualize hotspots in the history.
 Time estimated: 2 months.
\end_layout

\begin_layout Itemize
Experimentation with systems to evaluate and validate the approach.
 Time estimated: 3 months.
\end_layout

\begin_layout Itemize
Analysis of the experimentation results.
 Time estimated: 1 month.
\end_layout

\begin_layout Itemize
Publication of results (in parallel with previous tasks).
 
\end_layout

\begin_layout Itemize
Writing of a thesis report (in parallel with previous tasks).
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "acm"

\end_inset


\end_layout

\end_body
\end_document
