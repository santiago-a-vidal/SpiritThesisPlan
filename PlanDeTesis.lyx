#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
date{}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Thesis Proposal
\begin_inset Newline newline
\end_inset


\series bold

\begin_inset VSpace bigskip
\end_inset


\series default
\size small
\color black
Submitted in partial fulfillment of the requirements for the degree of
\size default
\color inherit

\begin_inset Newline newline
\end_inset

Ph.D.
 in Computer Science
\end_layout

\begin_layout Standard
\align center

\series bold
SpIRIT: Smart Identification of Refactoring opportunITies
\begin_inset Newline newline
\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Mg.
 Santiago A.
 Vidal
\end_layout

\begin_layout Standard
\align center
Student
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Dra.
 Claudia A.
 Marcos
\end_layout

\begin_layout Standard
\align center
Advisor 
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
Dr.
 Andrés Díaz Pace
\end_layout

\begin_layout Standard
\align center
Co-Advisor
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Address
\align center
Facultad de Ciencias Exactas
\begin_inset Newline newline
\end_inset

Departamento de Computación y Sistemas
\begin_inset Newline newline
\end_inset

Universidad Nacional del Centro de la Pcia.
 de Bs.
 As.
\begin_inset Newline newline
\end_inset

February 2012
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Abstract
\end_layout

\begin_layout Section*

\lang spanish
Resumen
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Section
System Evolution
\end_layout

\begin_layout Standard
Once systems are developed and deployed, they will become progressively
 less useful owing to changes in the environment 
\begin_inset CommandInset citation
LatexCommand citep
key "Lehman1985"

\end_inset

.
 This behavior causes software aging 
\begin_inset CommandInset citation
LatexCommand citep
key "Parnas1994"

\end_inset

 and the need to evolve the system to new requirements preserving the architectu
re and simplicity of the software.
 This situation was identified by Lehman 
\begin_inset CommandInset citation
LatexCommand cite
key "Lehman1985"

\end_inset

 specifically by the following laws:
\end_layout

\begin_layout Itemize
Continuing Change: A system that is used in a real-world environment must
 be continually adapted, otherwise it becomes progressively less satisfactory.
\end_layout

\begin_layout Itemize
Increasing Complexity: As a system is evolved, its complexity increases
 unless work is done to maintain or reduce it.
\end_layout

\begin_layout Standard
An inference from these laws is that software maintenance is necessary in
 order to avoid these problems and to simplify the evolution of systems.
 Software maintenance is defined as:
\end_layout

\begin_layout Itemize
The process of modifying a software system or component after delivery to
 correct faults, improve performance or other attributes, or adapt to a
 changed environment 
\begin_inset CommandInset citation
LatexCommand cite
key "IEEE1999-Std610-12"

\end_inset

.
\end_layout

\begin_layout Itemize
The software product undergoes modification to code and associated documentation
 due to a problem or the need for improvement.
 The objective is to modify the existing software product while preserving
 its integrity 
\begin_inset CommandInset citation
LatexCommand cite
key "ISOStd"

\end_inset

.
\end_layout

\begin_layout Standard
Maintenance activities have been categorized into four classes 
\begin_inset CommandInset citation
LatexCommand cite
key "Lientz1980"

\end_inset

:
\end_layout

\begin_layout Itemize
Adaptive: modification of software environment.
\end_layout

\begin_layout Itemize
Perfective: implementation of new user requirements.
\end_layout

\begin_layout Itemize
Corrective: reparation of errors.
\end_layout

\begin_layout Itemize
Preventive: prevention of future problems.
\end_layout

\begin_layout Standard
Some research has shown that approximately 75% of maintenance falls into
 adaptive and perfective classes 
\begin_inset CommandInset citation
LatexCommand cite
key "Lientz1980,Nosek"

\end_inset

.
 That is to say that the addition of new user requirements or the modification
 of the existing ones is one of the main problems of software evolution
 and maintenance 
\begin_inset CommandInset citation
LatexCommand cite
key "Bennett2000"

\end_inset

.
\end_layout

\begin_layout Standard
In order to make changes in a system, it is necessary to understand it.
 This is hard to do because when a legacy system must be extended or adapted
 some of the following problems may emerge 
\begin_inset CommandInset citation
LatexCommand cite
key "Demeyer2003"

\end_inset

: the original developers are not available, obsolete programming techniques
 or languages were used, large changes were applied without regard to the
 original design, the documentation is incomplete or it does not exist,
 there are no test cases, etc.
 All of these problems make maintenance difficult and expensive.
 Another attribute of the system that must be considered is its complexity.
 The more complex a system is, the more expensive it is to maintain 
\begin_inset CommandInset citation
LatexCommand cite
key "Banker1993"

\end_inset

.
 
\end_layout

\begin_layout Standard
For these reasons, in order to extend or adapt a legacy system, a reverse
 engineering application is used 
\begin_inset CommandInset citation
LatexCommand cite
key "Cross1992"

\end_inset

.
 Reverse engineering is the process of analyzing a subject system to identify
 the system’s components and their interrelationships and create representations
 of the system in another form or at a higher level of abstraction.
 Once the system is understood, new requirements can be added to the system
 through re-engineering 
\begin_inset CommandInset citation
LatexCommand citep
key "Cross1992"

\end_inset

.
 Re-engineering is the examination and modification of a subject system
 to reconstitute it in a new form and the subsequent implementation of the
 new form.
 This process is illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Addition-of-requirements"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ReverseEngineeringAndReengineering.eps
	BoundingBox 25bp 595bp 375bp 827bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Addition of requirements to a legacy system.
\begin_inset CommandInset label
LatexCommand label
name "fig:Addition-of-requirements"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Incorporating requirements involves the addition of new source code and/or
 restructuring the existing code taking into account the maintainability
 and modularity of the resulting code.
 The technique known as refactoring 
\begin_inset CommandInset citation
LatexCommand citep
key "Fowler1999"

\end_inset

 is used in order to achieve this goal.
 Refactoring is the process of changing a software system in such a way
 that it does not alter the external behavior of the code yet improves its
 internal structure.
 This process allows the restructuration of the source code improving the
 time it takes and the effort needed to make future modifications of the
 system.
 Some benefits that are derived from the refactoring application are: reduction
 of duplicate code, improvement of quality attributes such as the legibility
 of the code, maintenance, or reduction of coupling.
 For these reasons, refactoring can be seen as a viable strategy to deal
 with software evolution.
 Furthermore, some methodologies of agile development, such as XP 
\begin_inset CommandInset citation
LatexCommand cite
key "Beck2004"

\end_inset

, present refactoring as one of the most important practices.
\end_layout

\begin_layout Standard
The activities for the refactoring application can be summed up as follows
 
\begin_inset CommandInset citation
LatexCommand cite
key "Mens2004"

\end_inset

:
\end_layout

\begin_layout Enumerate
Identify the code fragments where the system should be refactored.
\end_layout

\begin_layout Enumerate
Determine which refactorings should be applied to the identified code fragments.
\end_layout

\begin_layout Enumerate
Check whether the refactoring to be applied preserves the external behavior
 of the code.
 
\end_layout

\begin_layout Enumerate
Apply the refactoring.
\end_layout

\begin_layout Enumerate
Assess the effects of the refactoring on quality characteristics of the
 software (e.g., complexity, maintainability) or the process (e.g., productivity,
 cost, effort).
 
\end_layout

\begin_layout Enumerate
Maintain the consistency between the refactored code and the other software
 artifacts (e.g., documentation, requirements, tests).
\end_layout

\begin_layout Standard
With the goal of easily applying a refactoring, most of the current IDEs
 (e.g., Eclipse
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.eclipse.org/
\end_layout

\end_inset

, NetBeans
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.netbeans.org/
\end_layout

\end_inset

) include tools that support refactoring by allowing its application semi-automa
tically.
 These tools are useful because they increase productivity and reduce debugging
 and testing 
\begin_inset CommandInset citation
LatexCommand cite
key "OConnor2005"

\end_inset

.
\end_layout

\begin_layout Section
Improving Maintenance with Refactoring
\end_layout

\begin_layout Standard
As mentioned above, the first activity of a refactoring process is the identific
ation of the code fragments that should be refactorized in order to improve
 its evolvability.
 This activity is usually achieve by the use of code smells 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

.
 Code smells are symptoms in the source code that usually allow the identificati
on of a deeper problem.
 In this way, the code smells acts as an anti-pattern indicating code that
 should be improved.
 Some of the symptoms used by code smells are duplicated code, methods or
 classes too large, too many parameters, violations in the encapsulation
 of a class, etc.
 The most popular catalog of code smells is that proposed by Fowler and
 Beck 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

 (Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:A-code-smell"

\end_inset

).
 For each code smell, there is an associated refactoring (or a group of
 them) to solve the problem.
 In order to help the developer to find code smells in systems, several
 tools have been presented such as PMD
\begin_inset Foot
status open

\begin_layout Plain Layout
http://pmd.sourceforge.net/
\end_layout

\end_inset

 and FindBugs
\begin_inset Foot
status open

\begin_layout Plain Layout
http://findbugs.sourceforge.net/
\end_layout

\end_inset

.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="9cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Code Smells
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Within Classes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comments, Dead Code, Duplicated Code, Inconsistent Names, Large Class, Long
 Method, Long Parameter List, Speculative Generality, Type Embedded in Name,
 Uncommunicative Name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Between Classes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data Class, Data Clumps, Divergent Change, Feature Envy, Inappropriate Intimacy,
 Lazy Class, Message Chains, Middle Man, Parallel Inheritance Hierarchies,
 Primitive Obsession, Refused Bequest, Shotgun Surgery
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A code smell catalog.
\begin_inset CommandInset label
LatexCommand label
name "tab:A-code-smell"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also, the use of object-oriented metrics 
\begin_inset CommandInset citation
LatexCommand cite
key "Chidamber1994"

\end_inset

 is useful to identify hot spots to be refactored.
 Through the use of this kind of metrics several problems can be spotted
 such as methods with high complexity or too many dependencies between classes.
\end_layout

\begin_layout Standard
Nevertheless, the identification of code fragments that should be refactorized
 is still a problem.
 Many of the bad smell identified by the refactoring tools not always indicate
 a problem.
 For example, some long methods are not necessarily a design problem.
 Also, the way in which a code smell should be refactored is not always
 trivial.
 In some case several restructurings of the code are needed in order to
 ensure that the behavior of the code does not change 
\begin_inset CommandInset citation
LatexCommand cite
key "Mens2004"

\end_inset

.
 
\end_layout

\begin_layout Standard
Another problem is that when tools are used to detect hot spots that should
 be refactored, they usually find a large number of them.
 So, the developer does not know with certainty which of them should have
 a higher priority because of they relevance.
 
\end_layout

\begin_layout Standard
The determination of the set of refactorings to be applied in order to solve
 a code smell is not trivial.
 This is because the refactoring to be applied depends on the code smell
 and the context in which the refactoring is applied.
 For example, in some scenarios the application of the refactoring proposed
 by the code smell is not possible.
 So, an additional refactoring should be applied in order to enable the
 application of the proposed refactoring.
 
\end_layout

\begin_layout Standard
Finally, when a hot spot is found the developer does not know the costs
 and benefits of refactoring it.
 This analysis should be based in time to completion and a set of metrics
 to show the developer the possible improvements in the quality of the source
 code.
\end_layout

\begin_layout Standard
For these reasons, 
\color black
we believe that it is desirable to have tools that provide better assistance
 to the developer during the refactoring process detecting hot spots, prioritizi
ng them, making automatic analysis of
\color inherit
 tradeoff and suggesting and applying refactorings.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
EXPLICAR BAD SMELLS
\end_layout

\begin_layout Plain Layout
TIENE QUE QUEDAR BIEN CLARO CUALES SON LOS PROBLEMAS QUE VAMOS A ATACAR
\end_layout

\begin_layout Plain Layout
Lo importante es discriminar: problemas concretos, hipotesis, enfoque de
 solucion.
\end_layout

\begin_layout Plain Layout
Los mayores problemas en el momento de realizar un refactoring son...
 Nosotros buscaremos solucionar esos problemas en este trabajo.
 
\end_layout

\begin_layout Plain Layout
Problemas:
\end_layout

\begin_layout Itemize
deteccion de los lugares a refactorizar en un sistema (hot spots)
\end_layout

\begin_layout Itemize
priorizacion de los hot spots segun que tan criticos son para el sistema
\end_layout

\begin_layout Itemize
Obtener un conjunto de posibles refactorings a aplicar
\end_layout

\begin_layout Itemize
"analisis costo-beneficio de los distintos refactorings que pueden ser aplicados
 para resolver el problema teniendo en cuenta las ventajas y desventajas
 de cada uno
\end_layout

\end_inset


\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
In this section we review different approaches for analyzing the evolution
 of systems.
\end_layout

\begin_layout Standard
Several approaches have been presented to analyze some aspects of the history
 of systems.
 Some of them try to discover bad smells in the source code in order to
 propose refactorings to remove them.
 
\end_layout

\begin_layout Standard
Chatzigeorgiou and Manakos 
\begin_inset CommandInset citation
LatexCommand cite
key "Chatzigeorgiou2010"

\end_inset

 study the evolution of the bad smells of a system through its history.
 Specifically, they analyze the occurrence of three kind of bad smell initially
 presented by Fowler 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

.
 This study identified that most of the bad smells were create when new
 features are added to the systems.
 Also, it identified that most of them were not removed.
\end_layout

\begin_layout Standard
Hayashi et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Hayashi2006"

\end_inset

 propose a software agent that analyzes the changes made by a developer
 in a system.
 If a change creates a bad smell the agent suggests a Fowler's refactoring
 to be applied.
 While some modifications, to be proposed by the agent, are formally defined
 in this paper, it is not clear how the agent identifies the bad smell or
 which kind of them are supported.
\end_layout

\begin_layout Standard
Ratzinger et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ratzinger2005"

\end_inset

 extends the definition of bad smells to 
\emph on
change smells
\emph default
 in order to identify possible classes of a system to be refactorized.
 This work proposes two change smells to identify coupling between classes.
 Specifically, one of them identifies the situation in which a main class
 of the systems is modified at the same time that other peripheral classes.
 The other smell identifies the situation in which a class only define access
 methods to its variables and other class implements features based on the
 first class.
 Once that a change smell is detected a Fowler's refactoring is proposed
 to be applied.
\end_layout

\begin_layout Standard
Liu et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Liu2011"

\end_inset

 analyze the relationships between a set of 11 bad smells with the goal
 of proposing an order of the refactorings to be applied when more than
 a bad smell was found in a fragment of code.
 The sequence of refactorings proposed is based on different criteria that
 allows a lower number of restructurings.
 However, it does not consider other factors, such as the severity of bad
 smells.
 Owing to the algorithm used to calculate the sequence of refactorings rely
 on a previous manual analysis of the dependencies between bad smell it
 is not possible to consider other bad smells in the sequences.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
We analyze the relationships among different kinds of bad smells and their
 influence on detection and resolution sequences.
 We identify the need to arrange detection and resolution sequences of different
 kinds of bad smells using a motivating example.
 We also recommend a resolution sequence for commonly occurring bad smells,
 and validate it on two nontrivial applications.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tsantalis and Chatzigeorgiou 
\begin_inset CommandInset citation
LatexCommand cite
key "Tsantalis2011"

\end_inset

 follow the hypothesis that those fragments of code that were modified in
 the past are more likely to be modified in the future.
 Using this hypothesis the authors rank refactoring suggestions to solve
 bad smell.
 In this ranking, those refactorings whose target code was modified in the
 past will have the highest priority.
 To calculate the probability of change of a component the approach uses
 historical volatility models taken from the field of financial markets.
\end_layout

\begin_layout Standard
Tsantalis and Chatzigeorgiou also present approaches to identify state-checking
 problems and the decomposition of large methods 
\begin_inset CommandInset citation
LatexCommand cite
key "Tsantalis2010,Tsantalis2011a"

\end_inset

.
 In these approaches the proposed refactorings are ranked according the
 impact of the refactorings on the code (i.e.
 number of modified statements).
\end_layout

\begin_layout Standard
Marinescu et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Marinescu2010"

\end_inset

 presents a tool to detect design problems through the use of bad smells.
 For each design problem detected, the tool proposes a list of 
\emph on
refactorings tips
\emph default
 to be applied.
\end_layout

\begin_layout Standard
Macia et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Macia2012,Macia2012a"

\end_inset

 analyze the impact of bad smells in the architectural design of systems.
 They found that, in 60% of cases, the removal of a bad smell helps the
 architecture, stopping its degradation.
 Also, they identify that some kind of bad smells negatively affects the
 evolution of systems.
 For this reason, they identification during early stages of the development
 of systems alleviate the architecture degradation process.
\end_layout

\begin_layout Standard
Other approaches have dealt with the use of software metrics to discover
 potential design problems in the source code.
\end_layout

\begin_layout Standard
Demeyer et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Demeyer2000"

\end_inset

 propose an approach to identify which refactorings were applied during
 the history of a system.
 This work is based on heuristics that use different metrics such as the
 total number of lines of code of a method or the number of hierarchy relationsh
ips of a class.
\end_layout

\begin_layout Standard
Gîrba et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Girba2004"

\end_inset

 present a technique to discover classes that should be refactorized.
 This work is based on the hypothesis that those classes that were modified
 more frequently in the past, are more likely to be modified in the future.
 For this reason, this work analyze each class of a version of a system
 using an algorithm that helps to determine the probability of change of
 the class in future versions.
 If the class is likely to change, then it is marked as candidate class
 to be refactored.
 To measure the change of a class between versions only the addition or
 deletion of methods is used.
 The paper does not cover the analysis of possible problems in the classes
 to be refactored or the suggestion of the refactorings that should be applied.
\end_layout

\begin_layout Standard
Gîrba and Ducasse 
\begin_inset CommandInset citation
LatexCommand cite
key "Girba2006"

\end_inset

 present a meta-model called Hismo to analyze the evolution of systems through
 their history.
 Hismo is constructed in a generic way (therefore, it can be used with any
 programming language) and it models evolution as a first class entity.
 The validation of this meta-model is conducted through it application to
 different case studies.
\end_layout

\begin_layout Standard
LinHui et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "LinHui2010"

\end_inset

 analyze the history of systems to identify the relationships between different
 modules of an architecture.
 Based on this information refactorings are proposed.
 Additionally, an interactive process based on domain-knowledge is proposed
 to apply the refactorings.
\end_layout

\begin_layout Standard
Ratzinger et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ratzinger2007"

\end_inset

 propose the use of data mining techniques to predict the refactorings applicati
on during the history of a system.
 Several metrics are used in the identification such as size of a class,
 number of authors of a class, complexity, number of bugs, etc.
 Using these metrics the approach identify the refactorings that were applied
 in the past.
 After the training phase the approach predicts the number of refactorings
 that could be applied in a future version.
\end_layout

\begin_layout Standard
Schofield et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Schofield2006"

\end_inset

 analyze the changes during the history of a system using heuristics.
 These heuristics are based on different metrics, analysis of return of
 inversions after an application of a refactorings, and differences of design
 between different versions.
\end_layout

\begin_layout Standard
Wong et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Wong2011"

\end_inset

 propose an approach to detect violations in the modularity of components.
 This detection is achieved by identifying which components had evolved
 together during the history of a system.
 In these cases the authors have the assumption that the component must
 be very coupled and a violation to the modularity must exist.
\end_layout

\begin_layout Standard
Xing and Stroulia 
\begin_inset CommandInset citation
LatexCommand cite
key "Xing2005"

\end_inset

 present an algorithm called UMLDiff to identify changes in the design between
 two versions of a system.
 The input of the algorithm are the UML meta-models of the classes to be
 compared.
 This algorithm is used in 
\begin_inset CommandInset citation
LatexCommand cite
key "Xing2003"

\end_inset

 to identify and classify those refactorings that were applied during the
 history of a system.
\end_layout

\begin_layout Standard
In order to identify the changes during the evolution of a system some approache
s have presented 
\end_layout

\begin_layout Standard
D'Ambros and Lanza 
\begin_inset CommandInset citation
LatexCommand cite
key "D'Ambros2009"

\end_inset

 present visualizations to analyze the evolution of a system based on its
 different versions.
 They present two groups of visualizations: 
\emph on
in the large
\emph default
, and 
\emph on
in the small
\emph default
.
 The former focuses on identifying changes and different commits into a
 class.
 The latter focuses on finding bugs in the classes and also on analyzing
 the size and complexity of them.
 
\end_layout

\begin_layout Standard
D'Ambros and Lanza 
\begin_inset CommandInset citation
LatexCommand cite
key "D'Ambros2010"

\end_inset

 propose an approach to analyze the evolution of systems using different
 kind of visualizations.
 The visualizations help to calculate coupling between modules, correlation
 between classes and complexity of classes.
 An interesting feature of this work is that it focuses on the collaborative
 work during the maintenance of a system through the addition of annotations
 on the visualizations of the components.
\end_layout

\begin_layout Standard
Lanza 
\begin_inset CommandInset citation
LatexCommand cite
key "Lanza2001"

\end_inset

 proposes the use of an evolution matrix to visualize the changes of classes
 during the history of a system.
 Each cell of the matrix contains a specific version of a class.
 A class is visualized as a rectangle where the width and height are defined
 based on metrics (e.g.
 number of methods and number of instance variables).
 This work also proposes a categorization of the classes visualized on the
 matrix.
 These categories are patterns found during the history and they are based
 on the size of the classes, the percentage of modification between versions,
 and the creation or deletion of classes.
 
\end_layout

\begin_layout Standard
Pinzger et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Pinzger2005"

\end_inset

 use Kiviat diagrams to analyze the trend of several metrics during the
 history of a system.
 The approach focuses on two kind of graphics: the fist one shows metrics
 for a module and the second one focuses on metrics related with the relationshi
ps between the modules.
\end_layout

\begin_layout Standard
Voinea et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Voinea2005"

\end_inset

 present a technique to visualize the evolution of systems using line-oriented
 displays.
 The different views presented have the goal of showing the changes of a
 component during the versions of a system, indicating the developers that
 made changes, establishing correlations between changes, and displaying
 which components have a higher ratio of volatility.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Habria que dividir los trabajos relacionados segun:
\end_layout

\begin_layout Itemize
Refactoring
\end_layout

\begin_layout Itemize
Analisis de historia
\end_layout

\begin_layout Itemize
Visualiacion
\end_layout

\begin_layout Plain Layout
Indicating the gap in knowledge and possible limitations 
\end_layout

\begin_layout Itemize
Few researchers have addressed the problem / issue / question of … 
\end_layout

\begin_layout Itemize
Previous work has only focused on / been limited to / failed to address
 … 
\end_layout

\begin_layout Itemize
A basic / common / fundamental / crucial / major issue of … 
\end_layout

\begin_layout Itemize
The central / core problem of 
\end_layout

\begin_layout Itemize
A challenging / An intriguing / An important / A neglected area in the field
 of … 
\end_layout

\begin_layout Itemize
Current solutions to X are inconsistent / inadequate / incorrect / ineffective
 / inefficient / over-simplistic / unsatisfactory 
\end_layout

\begin_layout Itemize
Many hypotheses regarding X appear to be ill-defined / unfounded / not well
 grounded / unsupported / questionable / disputable / debatable 
\end_layout

\begin_layout Itemize
The characteristics of X are not well understood / are misunderstood / have
 not been dealt with in depth.
 
\end_layout

\begin_layout Itemize
It is not yet known / has not yet been established whether X can do Y.
 
\end_layout

\begin_layout Itemize
X is still poorly / not widely understood.
 
\end_layout

\begin_layout Itemize
X is often impractical / not feasible / costly … 
\end_layout

\begin_layout Itemize
Techniques to solve X are computationally demanding / subject to high overheads
 / time consuming / impractical / frequently unfeasible.
 
\end_layout

\begin_layout Itemize
A major defect / difficulty / drawback / disadvantage / flaw of X is … 
\end_layout

\begin_layout Itemize
One of the main issues in our knowledge of / what we know about X is a lack
 of … 
\end_layout

\begin_layout Itemize
This particular / specific area of X has been overlooked / has been neglected
 / remains unclear … 
\end_layout

\begin_layout Itemize
Despite this interest, no one to the best of our knowledge / as far as we
 know has studied … 
\end_layout

\begin_layout Itemize
Although this approach is interesting, it suffers from / fails to take into
 account / does not allow for … 
\end_layout

\begin_layout Itemize
In spite of / Despite its shortcomings, this method has been widely applied
 to … 
\end_layout

\begin_layout Itemize
However, there is still a need for / has been little discussion on … 
\end_layout

\begin_layout Itemize
Moreover, other solutions / research programs / approaches have failed to
 provide … 
\end_layout

\begin_layout Itemize
Most studies have only focused / tended to focus on …
\end_layout

\begin_layout Itemize
To date / Until now this methodology has only been applied to … 
\end_layout

\begin_layout Itemize
There is still some / much / considerable controversy surrounding … 
\end_layout

\begin_layout Itemize
There has been some disagreement concerning / regarding / with regard to
 whether 
\end_layout

\begin_layout Itemize
There is little / no general agreement on … 
\end_layout

\begin_layout Itemize
The community has raised some issues / concerns about … 
\end_layout

\begin_layout Itemize
Concerns have arisen / been raised which question / call into question the
 validity of … 
\end_layout

\begin_layout Itemize
In the light of recent events in x, there is now some / much / considerable
 concern about …
\end_layout

\begin_layout Plain Layout
Giving general panorama of past-to-present literature 
\end_layout

\begin_layout Itemize
There is a considerable / vast amount of literature on … 
\end_layout

\begin_layout Itemize
In the literature there are many / several / a surprising number of / few
 examples of … 
\end_layout

\begin_layout Itemize
What we know / is known about X is largely based on … 
\end_layout

\begin_layout Itemize
Much / Not much / Very little is known about … 
\end_layout

\begin_layout Itemize
Many / Few studies have been published on … [Ref] 
\end_layout

\begin_layout Itemize
Various approaches have been proposed / put forward / suggested / hypothesized
 to solve this issue [Ref].
 
\end_layout

\begin_layout Itemize
X has been identified / indicated as being … [Ref] 
\end_layout

\begin_layout Itemize
X has been shown / demonstrated / proved / found to be … [Ref] 
\end_layout

\begin_layout Itemize
X has been widely investigated / studied / addressed … [Ref] 
\end_layout

\begin_layout Itemize
Xs have been receiving / gaining much attention due to … 
\end_layout

\begin_layout Itemize
In the traditional / classical approach, X is used to … 
\end_layout

\begin_layout Itemize
In recent years there has been considerable / growing interest in … [Ref]
\end_layout

\begin_layout Itemize
A growing body of literature has examined / investigated / studied / analyzed
 / evaluated … [Ref] 
\end_layout

\begin_layout Itemize
Much work on the potential of X has been carried out [Ref], yet / however
 there are still some critical issues … [Ref]
\end_layout

\begin_layout Plain Layout
Using the opinions of others to justify your criticism of someone’s work
 
\end_layout

\begin_layout Itemize
As mentioned by Burgess [2011], Henri’s argument / approach / reasoning
 relies too heavily on … 
\end_layout

\begin_layout Itemize
As others have highlighted [34, 45, 60], Ozil’s approach raises many doubts
 / is questionable … 
\end_layout

\begin_layout Itemize
Several authors / experts / researchers / analysts have expressed doubts
 about / called into question / challenged Guyot on the grounds that …..
 
\end_layout

\begin_layout Itemize
Marchesi [2010] has already noted an inconsistency with Hahn’s claim / methodolo
gy / method / results / approach … 
\end_layout

\begin_layout Itemize
Friedrich’s approach [2013] has not escaped criticism / been subjected to
 much criticism and has been strongly / vigorously challenged … 
\end_layout

\begin_layout Itemize
Many experts now contend / believe / argue that rather than using Pappov’s
 approach it might be more useful to … 
\end_layout

\begin_layout Itemize
Their analysis has not found / met with / received general acceptance …
 
\end_layout

\begin_layout Itemize
Some recent criticisms of / critical comments on Kim’s work are summarized
 in [25].
 
\end_layout

\begin_layout Itemize
The most well-known critic of Sadie’s findings is … who argued / proposed
 / suggested that an alternative explanation might be that / could be found
 in …
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Previous work has been limited to propose refactorings to those approaches
 that look for bad smells.
 The approaches that use software metrics usually only focus on discovering
 the problems but no solutions are proposed.
 Also, few researchers have worked on software metrics related to package
 or methods levels, instead, most of them are based on classes.
 Additionally, there is still a need for analyzing the relationship between
 methods, classes, and packages in order to discover design flaws.
\end_layout

\begin_layout Standard
A challenging issue is how to prioritize the refactorings to be proposed.
 We think that has been little discussion on the ranking of refactorings
 using several criteria and in the achievement of risk-benefit analysis
 of refactorings.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
It is evident that not all refactoring have the same importance or effect
 in a given situation.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Proposal
\end_layout

\begin_layout Standard
In order to performed a maintenance task, code refactorings 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

 must be applied to improve the internal structure of the source code without
 altering the external behavior of it.
 However, perform refactoring activities can be costly in time and money
 for developers and customers respectively.
 For this reason, the refactoring effort should be directed to restructure
 only those code fragments that are critical for the systems.
\end_layout

\begin_layout Standard
Along this line, in this Ph.
 D.
 thesis we propose the definition of a process that helps developers to
 achieve the task of refactoring an object-oriented system in order to improve
 its maintenance and evolvability.
 
\color black
We call this process SpIRIT: Smart Identification of Refactoring opportunITies.
 The goal of Spirit is to assist the developer during the refactorization
 process in order to simplify this task.
 For this reason, the proposed approach assists the developer detecting
 hot spots to be refactored, prioritizing them, making automatic analysis
 of the costs and benefits of refactoring the hot spots and suggesting and
 applying refactorings.
 
\end_layout

\begin_layout Standard

\color black
Spirit intends to be a multi-language analysis tool, for this reason it
 will be build using Moose
\begin_inset Foot
status open

\begin_layout Plain Layout

\color black
http://moosetechnology.org/
\end_layout

\end_inset

 which is a platform for software analysis that allows the import of several
 programming languages such as Smalltalk, Java or C++.
\end_layout

\begin_layout Standard

\color black
The Spirit process consists of a set of activities in which a system is
 analyzed in order to find locations of the system that have potential architect
ural or maintainability problems.
 Then, owing to these hot spots need to be refactored but they importance
 is not the same, Spirit will prioritize them because of they relevance.
 When the developer choose a hot spot to be fixed, the process suggest a
 set of refactorings that are suitable to it.
 For each refactoring, Spirit will inform of the advantages and disadvantages
 of their application.
 Finally, the developer may choose to apply any of the listed refactorings.
\end_layout

\begin_layout Standard

\color black
In brief, in this 
\color inherit
Ph.
 D.

\color black
 thesis we expect to contribute to the maintenance and evolution of systems
 by proposing a refactoring process.
 This process will help developers to achieve the task of refactoring an
 object-oriented system by detecting an prioritizing hot spots to be refactored.
 Also, the process suggest refactorings to be applied in the hot spots and
 presents 
\color inherit
analysis of costs and benefits of applying each of them.
\end_layout

\begin_layout Standard
In the next section the approach is described in detail.
\end_layout

\begin_layout Section

\series bold
Smart Identification of Refactoring Opportunities
\end_layout

\begin_layout Standard
The Spirit process has as input an object-oriented system and it has as
 output the same system refactored.
 The goal is to identify and improve those fragments of code that difficult
 the maintenance and evolution of the systems.
\end_layout

\begin_layout Standard
The process has four steps (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:SPIRIT-process."

\end_inset

):
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/SpiritProcess.pdf
	scale 70
	BoundingBox 20bp 220bp 410bp 470bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
SPIRIT process.
\begin_inset CommandInset label
LatexCommand label
name "fig:SPIRIT-process."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Identifying hot spots: several techniques are going to be used to identify
 hot spots.
 Some of then are code smells 
\begin_inset CommandInset citation
LatexCommand cite
key "Fowler1999"

\end_inset

, heuristics based on object-oriented metrics 
\begin_inset CommandInset citation
LatexCommand cite
key "Lanza2001"

\end_inset

, anti-patterns to detect design violations 
\begin_inset CommandInset citation
LatexCommand cite
key "Wong2011"

\end_inset

, and test profiling 
\begin_inset CommandInset citation
LatexCommand cite
key "Bergel2012"

\end_inset

.
 These techniques are going to search for different problems in the source
 code.
 Each of them must going to be associated with a set of refactorings to
 fix it.
 Depending on kind of the technique, the last version of the system or the
 whole history of versions are going to be used to identify problems.
 The use of the whole history of versions is useful to identify special
 situations such as classes that have not been changed for a number of versions
 or a class that grows more than certain percentage regarding it previous
 version.
 We also will experiment by identifying techniques that occurs together
 in the history of a system.
 
\end_layout

\begin_layout Enumerate
Prioritizing hot spots: in order to determine the most critical hot spots
 we propose an approach based on the rate of modification of the component
 in time.
 That is, the refactorizations will be proposed only on those components
 which have suffered many changes over the life of the system.
 The hypothesis of this idea is if a component had many changes during its
 life is likely to continue having changes.
 The benefits of this approach are twofold.
 First, a more modifiable and maintainable system is obtained.
 Second, the cost of refactoring is lower because only specific components
 are restructured.
 Also, we plan to provide other kind of techniques to determine the priority
 of a hot spot such as the calculation of the quantitative ratio of improvement
 in the quality of the source code after the refactorization of a hot spot.
\end_layout

\begin_layout Enumerate
Suggesting refactorings: the refactorings to be suggested to the the developer
 will be those associated with the hot spot under analysis.
 However, owing to the refactoring to be applied depends on the context
 of the hot spot, the suggestion of the refactorings will also be based
 on the history of refactorings of the developer.
 That is, the process keeps a record of the refactorings applied by the
 developer and the circumstances in which those refactorings were applied.
 In this way, we will achieve the identification of additional refactorings
 to be applied in order to enable the application of the refactorings associated
 with the hot spots.
 Also, by mean of this technique the preferences of refactorization of a
 developer are implicitly identified.
\end_layout

\begin_layout Enumerate
Applying refactorings: The refactorings selected previously are applied
 so that the hot spot under analysis is fixed.
 The code refactorings are applied automatically by the process.
 The developer’s intervention is eventually necessary for some decisions,
 such as the choice of the name of a new method.
 However, this step, as well all the refactoring process, must be supervised
 by the developer.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Refactoring Patterns Recognition.
 EXPLICAR EL PROCESO PASO A PASO.
 POSIBLEMENTE CADA PASO AMERITE UNA SUBSECCION
\end_layout

\begin_layout Plain Layout
Aca tenemos que poner la hipotesis de la historia y otras hipotesis que
 haya
\end_layout

\begin_layout Plain Layout
Tambien poner algo de profiling
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To validate our approach we will use different strategies:
\end_layout

\begin_layout Itemize
Quantitative comparison
\begin_inset space \quad{}
\end_inset

By means of this strategy we plan to create a branch of a system in order
 to continue the development of it by using our approach (that is, refactorizing
 a hot spot in the new version but not in the original).
 At the same time, the development of the original version will continue.
 Then, we will compare the new versions of the systems using different metrics.
 
\end_layout

\begin_layout Itemize
Evaluation of other refactoring strategies
\begin_inset space \quad{}
\end_inset

In this strategy we will compare the results of refactoring the same hot
 spots using with different refactorings associated the the resolution of
 a hot spot.
 With this strategy we expect to analyze the improvements in the source
 code by the use of different metrics.
\end_layout

\begin_layout Itemize
Evaluation after refactoring
\begin_inset space \quad{}
\end_inset

Through this evaluation the changes in a component after refactoring it
 will be analyzed.
 If a better separation of the functionality was achieved by mean of the
 refactorization of a component, the changes in the component after refactoring
 it should decrease.
\end_layout

\begin_layout Section
State of Development
\end_layout

\begin_layout Section
Task Schedule
\end_layout

\begin_layout Standard
In this section we describe the activities that must be accomplished in
 order to finish the proposed approach:
\end_layout

\begin_layout Itemize
Design and implementation of the Spirit user interface.
 Time estimated: 2 months.
\end_layout

\begin_layout Itemize
Design and implementation of the Spirit mechanisms to detect hotspots in
 the history to be refactored.
 Time estimated: 4 months.
\end_layout

\begin_layout Itemize
Design and implementation of the Spirit mechanisms to prioritize hotspots
 based on urgency.
 Time estimated: 2 months.
\end_layout

\begin_layout Itemize
Design and implementation of the Spirit mechanisms to rank refactorings
 to be applied to a hotspot based on risk-analysis.
 Time estimated: 5 months.
\end_layout

\begin_layout Itemize
Implementation of strategies to visualize hotspots in the history.
 Time estimated: 2 months.
\end_layout

\begin_layout Itemize
Experimentation with systems to evaluate and validate the approach.
 Time estimated: 3 months.
\end_layout

\begin_layout Itemize
Analysis of the experimentation results.
 Time estimated: 1 month.
\end_layout

\begin_layout Itemize
Publication of results (done simultaneously with the others tasks).
 
\end_layout

\begin_layout Itemize
Redaction of a thesis report.
 Time estimated: 3 months.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "acm"

\end_inset


\end_layout

\end_body
\end_document
